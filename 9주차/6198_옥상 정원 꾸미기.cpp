#include <iostream>
#include <stack>
using namespace std;

/*
10 3 7 4 12 2

//프로세스
1. 빈스택과 10을 비교한다.
2. 빈스택 시야 증가 += 0
3. 빈 스택에 10을 넣는다.

1. peek 10인 스택과 3을 비교한다.
2. 현재 스택의 시야 증가 [10] 1 증가
3. 3이 10보다 작아서 스택에 적재하고 스택의 peek이 3으로 바뀐다.

1. peek 3인 스택과 7을 비교한다.
2. 3이 7보다 작기 때문에 pop한다. peek는 10이 된다.
3. 현재 스택의 시야 증가 [10] 1 증가 -> 10이 바라봤던 숫자는 3, 7 해서 총 2이다.
4. 7을 스택에 적재하고 스택의 peek이 7로 바뀐다.

1. peek 7인 스택과 4를 비교한다.
2. 4가 7보다 작다.
3. 현재 스택의 시야 증가 [10][7] 1 증가.
4. 4를 적재한다.

1. 12가 들어왔다.
2. 스택을 계속 pop한다. 스택에 12보다 큰 수는 없었기 때문에 스택은 비게 된다.
3. 현재 스택의 시야 증가 0
4. 12를 적재한다.

...

//구현
1. for문을 돈다.
2. i번 인덱스가 가리키는 숫자를 본다.
3.2 분기 1. 스택이 비어있거나 끝에 있는 숫자보다 작다 -> 스택에 넣는다.
		   3-1-1. 스택에 들어있는 값들이 볼 수 있는 시야를 각각 1씩 증가시킨다.-> 이것은 스택사이즈를 의미한다.
					예를 들면, 스택에 10, 7, 4가 들어있을 때 스택 사이즈를 증가시키면 
						10쳐다볼 수 있는 범위 +1
						7이 쳐다볼 수 있는 범위 +1
						4가 쳐다볼 수 있는 범위 +1이 된다.

						각 숫자마다 얼마나 쳐다볼 수 있는지 보는게 아니라
						매번 스택에 들어있는 숫자가 살아남는지 여부를 보는게 맞는거같다..

3.2 분기 2. 스택의 끝자리보다 크다 -> 인덱스 숫자보다 큰 숫자가 나오거나 스택이 빌 때까지 스택을 비운다.
*/

int main()
{
	int N, num;
	long long answer = 0;
	stack<int> stack;
	stack.push(2147483647);
	cin >> N;
	while (N--)
	{
		cin >> num;			
		
		//num을 스택의 top과 비교한다.
		//num이 스택의 top보다 크거나 같으면 num보다 큰 수가 나올때까지 pop을 돌린다.
		while (stack.top() <= num)
			stack.pop();

		//★ 현재 스택에 쌓여있는 건물들의 시야를 1씩 증가시켜준다. -> 이는 스택의 사이즈와 같다.
		answer += (long long)(stack.size()-1);

		stack.push(num);
	}
	cout << answer;
}